/*
 * Generated by ./misc/optlib2c from optlib/rpmMacros.ctags, Don't edit this manually.
 */
#include "general.h"
#include "parse.h"
#include "routines.h"
#include "field.h"
#include "xtag.h"


static void initializeRpmMacrosParser (const langType language)
{

	addLanguageRegexTable (language, "main");
	addLanguageRegexTable (language, "comment");
	addLanguageRegexTable (language, "contline");
	addLanguageRegexTable (language, "mbody");
	addLanguageRegexTable (language, "mbody0");

	addLanguageTagMultiTableRegex (language, "main",
	                               "^#",
	                               "", "", "{tenter=comment}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^%([_a-zA-Z0-9]+)(\\([^)]*\\))*[^{\n\\\\]*([\n]|[\\\\][\n]|[{]|[\\\\])",
	                               "\\1", "m", ""
		"{{\n"
		"    \\2 false ne {\n"
		"       . \\2 signature:\n"
		"    } if\n"
		"    \\3 ({) eq {\n"
		"        .\n"
		"        /mbody _tenter\n"
		"    } if\n"
		"    \\3 (\\\\\\n) eq {\n"
		"        .\n"
		"        /contline _tenter\n"
		"    } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "main",
	                               "^.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "comment",
	                               "^[^\n]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "comment",
	                               "^[\n]",
	                               "", "", "{tleave}", NULL);
	addLanguageTagMultiTableRegex (language, "contline",
	                               "^(\n)",
	                               "", "", "{tleave}"
		"{{\n"
		"   @1 end:\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "contline",
	                               "^[^\n]*([^\n])\n?",
	                               "", "", ""
		"{{\n"
		"    \\1 (\\\\) eq not {\n"
		"       1@ end:\n"
		"       _tleave\n"
		"    } if\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody",
	                               "^([^\\\\{}#]+)",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "mbody",
	                               "^#",
	                               "", "", "{tenter=comment}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody",
	                               "^([{])",
	                               "", "", "{tenter=mbody0}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody",
	                               "^([}])",
	                               "", "", "{tleave}"
		"{{\n"
		"    dup :line @1 _matchloc2line eq {\n"
		"        pop\n"
		"    } {\n"
		"        @1 end:\n"
		"    } ifelse\n"
		"}}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody",
	                               "^\\\\.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "mbody0",
	                               "^[^\\\\{}#]+",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "mbody0",
	                               "^[{]",
	                               "", "", "{tenter=mbody0}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody0",
	                               "^#",
	                               "", "", "{tenter=comment}", NULL);
	addLanguageTagMultiTableRegex (language, "mbody0",
	                               "^\\\\.",
	                               "", "", "", NULL);
	addLanguageTagMultiTableRegex (language, "mbody0",
	                               "^([}])",
	                               "", "", "{tleave}", NULL);
}

extern parserDefinition* RpmMacrosParser (void)
{
	static const char *const extensions [] = {
		NULL
	};

	static const char *const aliases [] = {
		NULL
	};

	static const char *const patterns [] = {
		NULL
	};

	static const struct rExprSrc rexprs [] = {
		{
		  .expr = "(.*/)?macros\\.d/macros\\.([^/]+)$",
		  .iCase = false,
		},
		REXPR_LAST_ENTRY
	};

	static kindDefinition RpmMacrosKindTable [] = {
		{
		  true, 'm', "macro", "macros",
		},
	};

	parserDefinition* const def = parserNew ("RpmMacros");

	def->versionCurrent= 0;
	def->versionAge    = 0;
	def->enabled       = true;
	def->extensions    = extensions;
	def->patterns      = patterns;
	def->rexprs        = rexprs;
	def->aliases       = aliases;
	def->method        = METHOD_NOT_CRAFTED|METHOD_REGEX;
	def->useCork       = CORK_QUEUE;
	def->kindTable     = RpmMacrosKindTable;
	def->kindCount     = ARRAY_SIZE(RpmMacrosKindTable);
	def->initialize    = initializeRpmMacrosParser;

	return def;
}
